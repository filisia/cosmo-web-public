{"ast":null,"code":"import config from '../config';\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.listeners = new Set();\n    this.state = {\n      connecting: false,\n      connected: false,\n      shouldReconnect: true,\n      reconnectAttempts: 0\n    };\n    this.reconnectTimeout = null;\n    this.heartbeatInterval = null;\n    this.lastHeartbeat = null;\n    this.heartbeatTimeout = null;\n    this.url = config.wsUrl;\n    this.connectedDevices = [];\n    this.connectionState = false;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    console.log('[WebSocketService] Initialized with URL:', this.url);\n    console.log('[WebSocketService] Current page protocol:', typeof window !== 'undefined' ? window.location.protocol : 'unknown');\n    console.log('[WebSocketService] WebSocket URL protocol:', this.url.startsWith('ws://') ? 'ws://' : this.url.startsWith('wss://') ? 'wss://' : 'unknown');\n\n    // Auto-connect on initialization\n    setTimeout(() => {\n      console.log('[WebSocketService] Auto-connecting on initialization');\n      this.connect();\n    }, 1000);\n  }\n  isConnected() {\n    return this.connectionState;\n  }\n  addListener(listener) {\n    console.log('[WebSocketService] Adding listener, total listeners:', this.listeners.size + 1);\n    this.listeners.add(listener);\n    return () => {\n      console.log('[WebSocketService] Removing listener, remaining listeners:', this.listeners.size - 1);\n      this.listeners.delete(listener);\n    };\n  }\n  removeListener(listener) {\n    console.log('[WebSocketService] Removing listener, remaining listeners:', this.listeners.size - 1);\n    this.listeners.delete(listener);\n  }\n  notifyListeners(data) {\n    // console.log('[WebSocketService] Notifying listeners:', data.type, 'Total listeners:', this.listeners.size);\n    this.listeners.forEach(listener => {\n      try {\n        listener(data);\n      } catch (error) {\n        console.error('[WebSocketService] Error in listener:', error);\n      }\n    });\n  }\n  connect() {\n    console.log('[WebSocketService] Connect called. Current state:', {\n      connecting: this.state.connecting,\n      connected: this.state.connected,\n      shouldReconnect: this.state.shouldReconnect,\n      reconnectAttempts: this.state.reconnectAttempts\n    });\n    if (this.state.connecting || this.state.connected) {\n      console.log('[WebSocketService] Already connecting or connected, skipping connect');\n      return;\n    }\n    this.state.connecting = true;\n    console.log(`[WebSocketService] Attempting to connect to WebSocket at ${this.url}`);\n    try {\n      this.ws = new WebSocket(this.url);\n      this.ws.onopen = () => {\n        console.log('[WebSocketService] WebSocket Connected');\n        this.state.connecting = false;\n        this.state.connected = true;\n        this.state.reconnectAttempts = 0;\n        this.connectionState = true;\n        this.notifyListeners({\n          type: 'connected'\n        });\n        this.sendMessage({\n          type: 'getDevices'\n        });\n      };\n      this.ws.onclose = event => {\n        console.log('[WebSocketService] WebSocket Disconnected', {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean\n        });\n        this.state.connecting = false;\n        this.state.connected = false;\n        this.connectionState = false;\n        this.notifyListeners({\n          type: 'disconnected'\n        });\n        if (this.state.shouldReconnect && this.state.reconnectAttempts < this.maxReconnectAttempts) {\n          this.state.reconnectAttempts++;\n          const delay = Math.min(1000 * Math.pow(2, this.state.reconnectAttempts - 1), 30000);\n          console.log(`[WebSocketService] Attempting to reconnect in ${delay}ms (${this.state.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n          this.reconnectTimeout = setTimeout(() => {\n            this.connect();\n          }, delay);\n        } else {\n          console.log('[WebSocketService] Not attempting reconnect:', {\n            shouldReconnect: this.state.shouldReconnect,\n            reconnectAttempts: this.state.reconnectAttempts,\n            maxReconnectAttempts: this.maxReconnectAttempts\n          });\n        }\n      };\n      this.ws.onerror = error => {\n        console.error('[WebSocketService] WebSocket Error:', error);\n        this.state.connecting = false;\n        this.connectionState = false;\n        this.notifyListeners({\n          type: 'error',\n          error: 'Connection error occurred'\n        });\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('[WebSocketService] Received message:', data.type, data);\n          if (data.type === 'devices') {\n            var _data$devices, _data$devices2;\n            console.log('[WebSocketService] Received devices with', (_data$devices = data.devices) === null || _data$devices === void 0 ? void 0 : _data$devices.length, 'devices');\n            // Transform the devices data to show 'Available' instead of 'Connected' when connected is false\n            const transformedDevices = ((_data$devices2 = data.devices) === null || _data$devices2 === void 0 ? void 0 : _data$devices2.map(device => ({\n              ...device,\n              status: device.connected ? 'Connected' : 'Available'\n            }))) || [];\n            console.log('[WebSocketService] Transformed devices:', JSON.stringify(transformedDevices));\n            this.connectedDevices = transformedDevices;\n          }\n\n          // Special logging for button events\n          if (data.type === 'buttonStateChanged' || data.type === 'buttonPress' || data.type === 'buttonRelease') {\n            // console.log('[WebSocketService] ðŸŽ¯ BUTTON EVENT RECEIVED:', {\n            //   type: data.type,\n            //   deviceId: data.deviceId,\n            //   state: data.state || data.buttonState,\n            //   pressValue: data.pressValue,\n            //   timestamp: new Date().toISOString()\n            // });\n          }\n\n          // Handle error messages from the bridge\n          if (data.type === 'error') {\n            console.error('[WebSocketService] Bridge error:', data);\n            this.notifyListeners({\n              type: 'error',\n              error: data.error || 'Unknown error',\n              deviceId: data.deviceId,\n              operation: data.operation\n            });\n          } else {\n            console.log('[WebSocketService] Notifying listeners of message type:', data.type);\n            this.notifyListeners(data);\n          }\n        } catch (error) {\n          console.error('[WebSocketService] Error parsing message:', error);\n          console.error('[WebSocketService] Raw message that failed to parse:', event.data);\n          this.notifyListeners({\n            type: 'error',\n            error: 'Failed to parse message'\n          });\n        }\n      };\n    } catch (error) {\n      console.error('[WebSocketService] Error creating WebSocket:', error);\n      this.state.connecting = false;\n      this.connectionState = false;\n      this.notifyListeners({\n        type: 'error',\n        error: 'Failed to create WebSocket connection'\n      });\n    }\n  }\n  disconnect() {\n    console.log('[WebSocketService] Disconnect called. Current state:', {\n      connecting: this.state.connecting,\n      connected: this.state.connected,\n      shouldReconnect: this.state.shouldReconnect,\n      hasReconnectTimeout: !!this.reconnectTimeout\n    });\n\n    // Clear any polling intervals (remove if not needed anymore)\n    if (this.pollIntervals) {\n      console.log('[WebSocketService] Clearing polling intervals');\n      this.pollIntervals.forEach(interval => clearInterval(interval));\n      this.pollIntervals.clear();\n      this.pollIntervals = null; // Clean up the map\n    }\n    this.state.shouldReconnect = false;\n    if (this.reconnectTimeout) {\n      console.log('[WebSocketService] Clearing reconnect timeout');\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.ws) {\n      console.log('[WebSocketService] Closing WebSocket connection');\n      this.ws.close();\n      this.ws = null;\n    }\n    this.state.connecting = false;\n    this.state.connected = false;\n  }\n  async sendMessage(message) {\n    console.log('[WebSocketService] Sending message:', message);\n    if (!this.state.connected) {\n      console.error('[WebSocketService] Cannot send message - not connected');\n      throw new Error('WebSocket is not connected');\n    }\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws.send(JSON.stringify(message));\n        resolve();\n      } catch (error) {\n        console.error('[WebSocketService] Error sending message:', error);\n        reject(error);\n      }\n    });\n  }\n  async getDeviceInfo(deviceId) {\n    // Instead of getDeviceInfo, we'll use getDevices since that includes all device info\n    await this.sendMessage({\n      type: 'getDevices'\n    });\n  }\n  async subscribeToCharacteristic(deviceId, characteristicUUID) {\n    console.log('[WebSocketService] subscribeToCharacteristic called (no operation sent to bridge):', {\n      deviceId,\n      characteristicUUID\n    });\n    // This function is a no-op as the bridge sends characteristic updates automatically.\n  }\n  async writeCharacteristic(deviceId, characteristicUUID, value) {\n    await this.sendMessage({\n      type: 'writeCharacteristic',\n      deviceId,\n      characteristicUUID,\n      value\n    });\n  }\n  async readCharacteristic(deviceId, characteristicUUID) {\n    await this.sendMessage({\n      type: 'readCharacteristic',\n      deviceId,\n      characteristicUUID\n    });\n  }\n  getDevices() {\n    console.log('Getting devices list');\n    this.sendMessage({\n      type: 'getDevices'\n    });\n  }\n  setColor(deviceId, r, g, b) {\n    console.log('Setting color:', {\n      deviceId,\n      r,\n      g,\n      b\n    });\n    const sendColor = () => {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        let jsonToSend = {\n          type: 'setColor',\n          deviceId: deviceId,\n          color: {\n            r,\n            g,\n            b\n          }\n        };\n        this.ws.send(JSON.stringify(jsonToSend));\n        return true;\n      }\n      return false;\n    };\n\n    // Try to send immediately if connected\n    if (sendColor()) {\n      return;\n    }\n\n    // If not connected, try to reconnect and send\n    if (!this.state.connecting) {\n      console.log('[WebSocketService] Not connected, attempting to reconnect...');\n      this.connect();\n\n      // Wait for connection and retry\n      const checkConnection = setInterval(() => {\n        if (this.state.connected) {\n          clearInterval(checkConnection);\n          if (sendColor()) {\n            console.log('[WebSocketService] Successfully sent color after reconnection');\n          } else {\n            console.error('[WebSocketService] Failed to send color after reconnection');\n          }\n        }\n      }, 100);\n\n      // Clear interval after 5 seconds if still not connected\n      setTimeout(() => {\n        clearInterval(checkConnection);\n        if (!this.state.connected) {\n          console.error('[WebSocketService] Failed to reconnect within timeout');\n        }\n      }, 5000);\n    } else {\n      console.error('[WebSocketService] Already attempting to connect');\n    }\n  }\n  setMode(deviceId, mode) {\n    console.log('Setting mode:', {\n      deviceId,\n      mode\n    });\n    const sendMode = () => {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        let jsonToSend = {\n          type: 'setMode',\n          deviceId: deviceId,\n          data: [mode]\n        };\n        this.ws.send(JSON.stringify(jsonToSend));\n        return true;\n      }\n      return false;\n    };\n\n    // Try to send immediately if connected\n    if (sendMode()) {\n      return;\n    }\n\n    // If not connected, try to reconnect and send\n    if (!this.state.connecting) {\n      console.log('[WebSocketService] Not connected, attempting to reconnect...');\n      this.connect();\n\n      // Wait for connection and retry\n      const checkConnection = setInterval(() => {\n        if (this.state.connected) {\n          clearInterval(checkConnection);\n          if (sendMode()) {\n            console.log('[WebSocketService] Successfully sent mode after reconnection');\n          } else {\n            console.error('[WebSocketService] Failed to send mode after reconnection');\n          }\n        }\n      }, 100);\n\n      // Clear interval after 5 seconds if still not connected\n      setTimeout(() => {\n        clearInterval(checkConnection);\n        if (!this.state.connected) {\n          console.error('[WebSocketService] Failed to reconnect within timeout');\n        }\n      }, 5000);\n    } else {\n      console.error('[WebSocketService] Already attempting to connect');\n    }\n  }\n  setLuminosity(deviceId, intensity) {\n    // console.log('Setting luminosity:', { deviceId, intensity });\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      // intensity = Math.round((intensity * (64 - 5)) / 100) + 5;\n      let jsonToSend = {\n        type: 'setLuminosity',\n        deviceId: deviceId,\n        data: [intensity]\n      };\n      this.ws.send(JSON.stringify(jsonToSend));\n    } else {\n      console.error('WebSocket is not connected');\n    }\n  }\n}\n\n// Create a singleton instance\nconst wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["config","WebSocketService","constructor","ws","listeners","Set","state","connecting","connected","shouldReconnect","reconnectAttempts","reconnectTimeout","heartbeatInterval","lastHeartbeat","heartbeatTimeout","url","wsUrl","connectedDevices","connectionState","maxReconnectAttempts","reconnectDelay","console","log","window","location","protocol","startsWith","setTimeout","connect","isConnected","addListener","listener","size","add","delete","removeListener","notifyListeners","data","forEach","error","WebSocket","onopen","type","sendMessage","onclose","event","code","reason","wasClean","delay","Math","min","pow","onerror","onmessage","JSON","parse","_data$devices","_data$devices2","devices","length","transformedDevices","map","device","status","stringify","deviceId","operation","disconnect","hasReconnectTimeout","pollIntervals","interval","clearInterval","clear","clearTimeout","close","message","Error","Promise","resolve","reject","send","getDeviceInfo","subscribeToCharacteristic","characteristicUUID","writeCharacteristic","value","readCharacteristic","getDevices","setColor","r","g","b","sendColor","readyState","OPEN","jsonToSend","color","checkConnection","setInterval","setMode","mode","sendMode","setLuminosity","intensity","wsService"],"sources":["/Users/abinop/code/CosmoCode/cosmo-web-public/src/services/WebSocketService.js"],"sourcesContent":["import config from '../config';\n\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.listeners = new Set();\n    this.state = {\n      connecting: false,\n      connected: false,\n      shouldReconnect: true,\n      reconnectAttempts: 0\n    };\n    this.reconnectTimeout = null;\n    this.heartbeatInterval = null;\n    this.lastHeartbeat = null;\n    this.heartbeatTimeout = null;\n    this.url = config.wsUrl;\n    this.connectedDevices = [];\n    this.connectionState = false;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    console.log('[WebSocketService] Initialized with URL:', this.url);\n    console.log('[WebSocketService] Current page protocol:', typeof window !== 'undefined' ? window.location.protocol : 'unknown');\n    console.log('[WebSocketService] WebSocket URL protocol:', this.url.startsWith('ws://') ? 'ws://' : this.url.startsWith('wss://') ? 'wss://' : 'unknown');\n    \n    // Auto-connect on initialization\n    setTimeout(() => {\n      console.log('[WebSocketService] Auto-connecting on initialization');\n      this.connect();\n    }, 1000);\n  }\n\n  isConnected() {\n    return this.connectionState;\n  }\n\n  addListener(listener) {\n    console.log('[WebSocketService] Adding listener, total listeners:', this.listeners.size + 1);\n    this.listeners.add(listener);\n    return () => {\n      console.log('[WebSocketService] Removing listener, remaining listeners:', this.listeners.size - 1);\n      this.listeners.delete(listener);\n    };\n  }\n\n  removeListener(listener) {\n    console.log('[WebSocketService] Removing listener, remaining listeners:', this.listeners.size - 1);\n    this.listeners.delete(listener);\n  }\n\n  notifyListeners(data) {\n    // console.log('[WebSocketService] Notifying listeners:', data.type, 'Total listeners:', this.listeners.size);\n    this.listeners.forEach(listener => {\n      try {\n        listener(data);\n      } catch (error) {\n        console.error('[WebSocketService] Error in listener:', error);\n      }\n    });\n  }\n\n  connect() {\n    console.log('[WebSocketService] Connect called. Current state:', {\n      connecting: this.state.connecting,\n      connected: this.state.connected,\n      shouldReconnect: this.state.shouldReconnect,\n      reconnectAttempts: this.state.reconnectAttempts\n    });\n\n    if (this.state.connecting || this.state.connected) {\n      console.log('[WebSocketService] Already connecting or connected, skipping connect');\n      return;\n    }\n\n    this.state.connecting = true;\n    console.log(`[WebSocketService] Attempting to connect to WebSocket at ${this.url}`);\n\n    try {\n      this.ws = new WebSocket(this.url);\n\n      this.ws.onopen = () => {\n        console.log('[WebSocketService] WebSocket Connected');\n        this.state.connecting = false;\n        this.state.connected = true;\n        this.state.reconnectAttempts = 0;\n        this.connectionState = true;\n        this.notifyListeners({ type: 'connected' });\n        this.sendMessage({ type: 'getDevices' });\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('[WebSocketService] WebSocket Disconnected', {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean\n        });\n        this.state.connecting = false;\n        this.state.connected = false;\n        this.connectionState = false;\n        this.notifyListeners({ type: 'disconnected' });\n\n        if (this.state.shouldReconnect && this.state.reconnectAttempts < this.maxReconnectAttempts) {\n          this.state.reconnectAttempts++;\n          const delay = Math.min(1000 * Math.pow(2, this.state.reconnectAttempts - 1), 30000);\n          console.log(`[WebSocketService] Attempting to reconnect in ${delay}ms (${this.state.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n          this.reconnectTimeout = setTimeout(() => {\n            this.connect();\n          }, delay);\n        } else {\n          console.log('[WebSocketService] Not attempting reconnect:', {\n            shouldReconnect: this.state.shouldReconnect,\n            reconnectAttempts: this.state.reconnectAttempts,\n            maxReconnectAttempts: this.maxReconnectAttempts\n          });\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('[WebSocketService] WebSocket Error:', error);\n        this.state.connecting = false;\n        this.connectionState = false;\n        this.notifyListeners({ \n          type: 'error',\n          error: 'Connection error occurred'\n        });\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('[WebSocketService] Received message:', data.type, data);\n          \n          if (data.type === 'devices') {\n            console.log('[WebSocketService] Received devices with', data.devices?.length, 'devices');\n            // Transform the devices data to show 'Available' instead of 'Connected' when connected is false\n            const transformedDevices = data.devices?.map(device => ({\n              ...device,\n              status: device.connected ? 'Connected' : 'Available'\n            })) || [];\n            console.log('[WebSocketService] Transformed devices:', JSON.stringify(transformedDevices));\n            this.connectedDevices = transformedDevices;\n          }\n          \n          // Special logging for button events\n          if (data.type === 'buttonStateChanged' || data.type === 'buttonPress' || data.type === 'buttonRelease') {\n            // console.log('[WebSocketService] ðŸŽ¯ BUTTON EVENT RECEIVED:', {\n            //   type: data.type,\n            //   deviceId: data.deviceId,\n            //   state: data.state || data.buttonState,\n            //   pressValue: data.pressValue,\n            //   timestamp: new Date().toISOString()\n            // });\n          }\n          \n          // Handle error messages from the bridge\n          if (data.type === 'error') {\n            console.error('[WebSocketService] Bridge error:', data);\n            this.notifyListeners({\n              type: 'error',\n              error: data.error || 'Unknown error',\n              deviceId: data.deviceId,\n              operation: data.operation\n            });\n          } else {\n            console.log('[WebSocketService] Notifying listeners of message type:', data.type);\n            this.notifyListeners(data);\n          }\n        } catch (error) {\n          console.error('[WebSocketService] Error parsing message:', error);\n          console.error('[WebSocketService] Raw message that failed to parse:', event.data);\n          this.notifyListeners({ \n            type: 'error',\n            error: 'Failed to parse message'\n          });\n        }\n      };\n    } catch (error) {\n      console.error('[WebSocketService] Error creating WebSocket:', error);\n      this.state.connecting = false;\n      this.connectionState = false;\n      this.notifyListeners({ \n        type: 'error',\n        error: 'Failed to create WebSocket connection'\n      });\n    }\n  }\n\n  disconnect() {\n    console.log('[WebSocketService] Disconnect called. Current state:', {\n      connecting: this.state.connecting,\n      connected: this.state.connected,\n      shouldReconnect: this.state.shouldReconnect,\n      hasReconnectTimeout: !!this.reconnectTimeout\n    });\n\n    // Clear any polling intervals (remove if not needed anymore)\n    if (this.pollIntervals) {\n      console.log('[WebSocketService] Clearing polling intervals');\n      this.pollIntervals.forEach(interval => clearInterval(interval));\n      this.pollIntervals.clear();\n      this.pollIntervals = null; // Clean up the map\n    }\n\n    this.state.shouldReconnect = false;\n    if (this.reconnectTimeout) {\n      console.log('[WebSocketService] Clearing reconnect timeout');\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.ws) {\n      console.log('[WebSocketService] Closing WebSocket connection');\n      this.ws.close();\n      this.ws = null;\n    }\n    this.state.connecting = false;\n    this.state.connected = false;\n  }\n\n  async sendMessage(message) {\n    console.log('[WebSocketService] Sending message:', message);\n    if (!this.state.connected) {\n      console.error('[WebSocketService] Cannot send message - not connected');\n      throw new Error('WebSocket is not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws.send(JSON.stringify(message));\n        resolve();\n      } catch (error) {\n        console.error('[WebSocketService] Error sending message:', error);\n        reject(error);\n      }\n    });\n  }\n\n  async getDeviceInfo(deviceId) {\n    // Instead of getDeviceInfo, we'll use getDevices since that includes all device info\n    await this.sendMessage({ type: 'getDevices' });\n  }\n\n  async subscribeToCharacteristic(deviceId, characteristicUUID) {\n    console.log('[WebSocketService] subscribeToCharacteristic called (no operation sent to bridge):', { deviceId, characteristicUUID });\n    // This function is a no-op as the bridge sends characteristic updates automatically.\n  }\n\n  async writeCharacteristic(deviceId, characteristicUUID, value) {\n    await this.sendMessage({\n      type: 'writeCharacteristic',\n      deviceId,\n      characteristicUUID,\n      value\n    });\n  }\n\n  async readCharacteristic(deviceId, characteristicUUID) {\n    await this.sendMessage({\n      type: 'readCharacteristic',\n      deviceId,\n      characteristicUUID\n    });\n  }\n\n  getDevices() {\n    console.log('Getting devices list');\n    this.sendMessage({\n      type: 'getDevices'\n    });\n  }\n\n  setColor(deviceId, r, g, b) {\n    console.log('Setting color:', { deviceId, r, g, b });\n    const sendColor = () => {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        let jsonToSend = {\n          type: 'setColor',\n          deviceId: deviceId,\n          color: { r, g, b }\n        };\n        this.ws.send(JSON.stringify(jsonToSend));\n        return true;\n      }\n      return false;\n    };\n\n    // Try to send immediately if connected\n    if (sendColor()) {\n      return;\n    }\n\n    // If not connected, try to reconnect and send\n    if (!this.state.connecting) {\n      console.log('[WebSocketService] Not connected, attempting to reconnect...');\n      this.connect();\n      \n      // Wait for connection and retry\n      const checkConnection = setInterval(() => {\n        if (this.state.connected) {\n          clearInterval(checkConnection);\n          if (sendColor()) {\n            console.log('[WebSocketService] Successfully sent color after reconnection');\n          } else {\n            console.error('[WebSocketService] Failed to send color after reconnection');\n          }\n        }\n      }, 100);\n\n      // Clear interval after 5 seconds if still not connected\n      setTimeout(() => {\n        clearInterval(checkConnection);\n        if (!this.state.connected) {\n          console.error('[WebSocketService] Failed to reconnect within timeout');\n        }\n      }, 5000);\n    } else {\n      console.error('[WebSocketService] Already attempting to connect');\n    }\n  }\n\n  setMode(deviceId, mode) {\n    console.log('Setting mode:', { deviceId, mode });\n    const sendMode = () => {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        let jsonToSend = {\n          type: 'setMode',\n          deviceId: deviceId,\n          data: [mode]\n        };\n        this.ws.send(JSON.stringify(jsonToSend));\n        return true;\n      }\n      return false;\n    };\n\n    // Try to send immediately if connected\n    if (sendMode()) {\n      return;\n    }\n\n    // If not connected, try to reconnect and send\n    if (!this.state.connecting) {\n      console.log('[WebSocketService] Not connected, attempting to reconnect...');\n      this.connect();\n      \n      // Wait for connection and retry\n      const checkConnection = setInterval(() => {\n        if (this.state.connected) {\n          clearInterval(checkConnection);\n          if (sendMode()) {\n            console.log('[WebSocketService] Successfully sent mode after reconnection');\n          } else {\n            console.error('[WebSocketService] Failed to send mode after reconnection');\n          }\n        }\n      }, 100);\n\n      // Clear interval after 5 seconds if still not connected\n      setTimeout(() => {\n        clearInterval(checkConnection);\n        if (!this.state.connected) {\n          console.error('[WebSocketService] Failed to reconnect within timeout');\n        }\n      }, 5000);\n    } else {\n      console.error('[WebSocketService] Already attempting to connect');\n    }\n  }\n\n  setLuminosity(deviceId, intensity) {\n    // console.log('Setting luminosity:', { deviceId, intensity });\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      // intensity = Math.round((intensity * (64 - 5)) / 100) + 5;\n      let jsonToSend = {\n        type: 'setLuminosity',\n        deviceId: deviceId,\n        data: [intensity]\n      };\n      this.ws.send(JSON.stringify(jsonToSend));\n    } else {\n      console.error('WebSocket is not connected');\n    }\n  }\n}\n\n// Create a singleton instance\nconst wsService = new WebSocketService();\nexport default wsService; "],"mappings":"AAAA,OAAOA,MAAM,MAAM,WAAW;AAE9B,MAAMC,gBAAgB,CAAC;EACrBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,EAAE,GAAG,IAAI;IACd,IAAI,CAACC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC1B,IAAI,CAACC,KAAK,GAAG;MACXC,UAAU,EAAE,KAAK;MACjBC,SAAS,EAAE,KAAK;MAChBC,eAAe,EAAE,IAAI;MACrBC,iBAAiB,EAAE;IACrB,CAAC;IACD,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,GAAG,GAAGf,MAAM,CAACgB,KAAK;IACvB,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1BC,OAAO,CAACC,GAAG,CAAC,0CAA0C,EAAE,IAAI,CAACP,GAAG,CAAC;IACjEM,OAAO,CAACC,GAAG,CAAC,2CAA2C,EAAE,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACC,QAAQ,CAACC,QAAQ,GAAG,SAAS,CAAC;IAC9HJ,OAAO,CAACC,GAAG,CAAC,4CAA4C,EAAE,IAAI,CAACP,GAAG,CAACW,UAAU,CAAC,OAAO,CAAC,GAAG,OAAO,GAAG,IAAI,CAACX,GAAG,CAACW,UAAU,CAAC,QAAQ,CAAC,GAAG,QAAQ,GAAG,SAAS,CAAC;;IAExJ;IACAC,UAAU,CAAC,MAAM;MACfN,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;MACnE,IAAI,CAACM,OAAO,CAAC,CAAC;IAChB,CAAC,EAAE,IAAI,CAAC;EACV;EAEAC,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACX,eAAe;EAC7B;EAEAY,WAAWA,CAACC,QAAQ,EAAE;IACpBV,OAAO,CAACC,GAAG,CAAC,sDAAsD,EAAE,IAAI,CAAClB,SAAS,CAAC4B,IAAI,GAAG,CAAC,CAAC;IAC5F,IAAI,CAAC5B,SAAS,CAAC6B,GAAG,CAACF,QAAQ,CAAC;IAC5B,OAAO,MAAM;MACXV,OAAO,CAACC,GAAG,CAAC,4DAA4D,EAAE,IAAI,CAAClB,SAAS,CAAC4B,IAAI,GAAG,CAAC,CAAC;MAClG,IAAI,CAAC5B,SAAS,CAAC8B,MAAM,CAACH,QAAQ,CAAC;IACjC,CAAC;EACH;EAEAI,cAAcA,CAACJ,QAAQ,EAAE;IACvBV,OAAO,CAACC,GAAG,CAAC,4DAA4D,EAAE,IAAI,CAAClB,SAAS,CAAC4B,IAAI,GAAG,CAAC,CAAC;IAClG,IAAI,CAAC5B,SAAS,CAAC8B,MAAM,CAACH,QAAQ,CAAC;EACjC;EAEAK,eAAeA,CAACC,IAAI,EAAE;IACpB;IACA,IAAI,CAACjC,SAAS,CAACkC,OAAO,CAACP,QAAQ,IAAI;MACjC,IAAI;QACFA,QAAQ,CAACM,IAAI,CAAC;MAChB,CAAC,CAAC,OAAOE,KAAK,EAAE;QACdlB,OAAO,CAACkB,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;MAC/D;IACF,CAAC,CAAC;EACJ;EAEAX,OAAOA,CAAA,EAAG;IACRP,OAAO,CAACC,GAAG,CAAC,mDAAmD,EAAE;MAC/Df,UAAU,EAAE,IAAI,CAACD,KAAK,CAACC,UAAU;MACjCC,SAAS,EAAE,IAAI,CAACF,KAAK,CAACE,SAAS;MAC/BC,eAAe,EAAE,IAAI,CAACH,KAAK,CAACG,eAAe;MAC3CC,iBAAiB,EAAE,IAAI,CAACJ,KAAK,CAACI;IAChC,CAAC,CAAC;IAEF,IAAI,IAAI,CAACJ,KAAK,CAACC,UAAU,IAAI,IAAI,CAACD,KAAK,CAACE,SAAS,EAAE;MACjDa,OAAO,CAACC,GAAG,CAAC,sEAAsE,CAAC;MACnF;IACF;IAEA,IAAI,CAAChB,KAAK,CAACC,UAAU,GAAG,IAAI;IAC5Bc,OAAO,CAACC,GAAG,CAAE,4DAA2D,IAAI,CAACP,GAAI,EAAC,CAAC;IAEnF,IAAI;MACF,IAAI,CAACZ,EAAE,GAAG,IAAIqC,SAAS,CAAC,IAAI,CAACzB,GAAG,CAAC;MAEjC,IAAI,CAACZ,EAAE,CAACsC,MAAM,GAAG,MAAM;QACrBpB,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;QACrD,IAAI,CAAChB,KAAK,CAACC,UAAU,GAAG,KAAK;QAC7B,IAAI,CAACD,KAAK,CAACE,SAAS,GAAG,IAAI;QAC3B,IAAI,CAACF,KAAK,CAACI,iBAAiB,GAAG,CAAC;QAChC,IAAI,CAACQ,eAAe,GAAG,IAAI;QAC3B,IAAI,CAACkB,eAAe,CAAC;UAAEM,IAAI,EAAE;QAAY,CAAC,CAAC;QAC3C,IAAI,CAACC,WAAW,CAAC;UAAED,IAAI,EAAE;QAAa,CAAC,CAAC;MAC1C,CAAC;MAED,IAAI,CAACvC,EAAE,CAACyC,OAAO,GAAIC,KAAK,IAAK;QAC3BxB,OAAO,CAACC,GAAG,CAAC,2CAA2C,EAAE;UACvDwB,IAAI,EAAED,KAAK,CAACC,IAAI;UAChBC,MAAM,EAAEF,KAAK,CAACE,MAAM;UACpBC,QAAQ,EAAEH,KAAK,CAACG;QAClB,CAAC,CAAC;QACF,IAAI,CAAC1C,KAAK,CAACC,UAAU,GAAG,KAAK;QAC7B,IAAI,CAACD,KAAK,CAACE,SAAS,GAAG,KAAK;QAC5B,IAAI,CAACU,eAAe,GAAG,KAAK;QAC5B,IAAI,CAACkB,eAAe,CAAC;UAAEM,IAAI,EAAE;QAAe,CAAC,CAAC;QAE9C,IAAI,IAAI,CAACpC,KAAK,CAACG,eAAe,IAAI,IAAI,CAACH,KAAK,CAACI,iBAAiB,GAAG,IAAI,CAACS,oBAAoB,EAAE;UAC1F,IAAI,CAACb,KAAK,CAACI,iBAAiB,EAAE;UAC9B,MAAMuC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAGD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC9C,KAAK,CAACI,iBAAiB,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC;UACnFW,OAAO,CAACC,GAAG,CAAE,iDAAgD2B,KAAM,OAAM,IAAI,CAAC3C,KAAK,CAACI,iBAAkB,IAAG,IAAI,CAACS,oBAAqB,MAAK,CAAC;UACzI,IAAI,CAACR,gBAAgB,GAAGgB,UAAU,CAAC,MAAM;YACvC,IAAI,CAACC,OAAO,CAAC,CAAC;UAChB,CAAC,EAAEqB,KAAK,CAAC;QACX,CAAC,MAAM;UACL5B,OAAO,CAACC,GAAG,CAAC,8CAA8C,EAAE;YAC1Db,eAAe,EAAE,IAAI,CAACH,KAAK,CAACG,eAAe;YAC3CC,iBAAiB,EAAE,IAAI,CAACJ,KAAK,CAACI,iBAAiB;YAC/CS,oBAAoB,EAAE,IAAI,CAACA;UAC7B,CAAC,CAAC;QACJ;MACF,CAAC;MAED,IAAI,CAAChB,EAAE,CAACkD,OAAO,GAAId,KAAK,IAAK;QAC3BlB,OAAO,CAACkB,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;QAC3D,IAAI,CAACjC,KAAK,CAACC,UAAU,GAAG,KAAK;QAC7B,IAAI,CAACW,eAAe,GAAG,KAAK;QAC5B,IAAI,CAACkB,eAAe,CAAC;UACnBM,IAAI,EAAE,OAAO;UACbH,KAAK,EAAE;QACT,CAAC,CAAC;MACJ,CAAC;MAED,IAAI,CAACpC,EAAE,CAACmD,SAAS,GAAIT,KAAK,IAAK;QAC7B,IAAI;UACF,MAAMR,IAAI,GAAGkB,IAAI,CAACC,KAAK,CAACX,KAAK,CAACR,IAAI,CAAC;UACnChB,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAEe,IAAI,CAACK,IAAI,EAAEL,IAAI,CAAC;UAEpE,IAAIA,IAAI,CAACK,IAAI,KAAK,SAAS,EAAE;YAAA,IAAAe,aAAA,EAAAC,cAAA;YAC3BrC,OAAO,CAACC,GAAG,CAAC,0CAA0C,GAAAmC,aAAA,GAAEpB,IAAI,CAACsB,OAAO,cAAAF,aAAA,uBAAZA,aAAA,CAAcG,MAAM,EAAE,SAAS,CAAC;YACxF;YACA,MAAMC,kBAAkB,GAAG,EAAAH,cAAA,GAAArB,IAAI,CAACsB,OAAO,cAAAD,cAAA,uBAAZA,cAAA,CAAcI,GAAG,CAACC,MAAM,KAAK;cACtD,GAAGA,MAAM;cACTC,MAAM,EAAED,MAAM,CAACvD,SAAS,GAAG,WAAW,GAAG;YAC3C,CAAC,CAAC,CAAC,KAAI,EAAE;YACTa,OAAO,CAACC,GAAG,CAAC,yCAAyC,EAAEiC,IAAI,CAACU,SAAS,CAACJ,kBAAkB,CAAC,CAAC;YAC1F,IAAI,CAAC5C,gBAAgB,GAAG4C,kBAAkB;UAC5C;;UAEA;UACA,IAAIxB,IAAI,CAACK,IAAI,KAAK,oBAAoB,IAAIL,IAAI,CAACK,IAAI,KAAK,aAAa,IAAIL,IAAI,CAACK,IAAI,KAAK,eAAe,EAAE;YACtG;YACA;YACA;YACA;YACA;YACA;YACA;UAAA;;UAGF;UACA,IAAIL,IAAI,CAACK,IAAI,KAAK,OAAO,EAAE;YACzBrB,OAAO,CAACkB,KAAK,CAAC,kCAAkC,EAAEF,IAAI,CAAC;YACvD,IAAI,CAACD,eAAe,CAAC;cACnBM,IAAI,EAAE,OAAO;cACbH,KAAK,EAAEF,IAAI,CAACE,KAAK,IAAI,eAAe;cACpC2B,QAAQ,EAAE7B,IAAI,CAAC6B,QAAQ;cACvBC,SAAS,EAAE9B,IAAI,CAAC8B;YAClB,CAAC,CAAC;UACJ,CAAC,MAAM;YACL9C,OAAO,CAACC,GAAG,CAAC,yDAAyD,EAAEe,IAAI,CAACK,IAAI,CAAC;YACjF,IAAI,CAACN,eAAe,CAACC,IAAI,CAAC;UAC5B;QACF,CAAC,CAAC,OAAOE,KAAK,EAAE;UACdlB,OAAO,CAACkB,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;UACjElB,OAAO,CAACkB,KAAK,CAAC,sDAAsD,EAAEM,KAAK,CAACR,IAAI,CAAC;UACjF,IAAI,CAACD,eAAe,CAAC;YACnBM,IAAI,EAAE,OAAO;YACbH,KAAK,EAAE;UACT,CAAC,CAAC;QACJ;MACF,CAAC;IACH,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdlB,OAAO,CAACkB,KAAK,CAAC,8CAA8C,EAAEA,KAAK,CAAC;MACpE,IAAI,CAACjC,KAAK,CAACC,UAAU,GAAG,KAAK;MAC7B,IAAI,CAACW,eAAe,GAAG,KAAK;MAC5B,IAAI,CAACkB,eAAe,CAAC;QACnBM,IAAI,EAAE,OAAO;QACbH,KAAK,EAAE;MACT,CAAC,CAAC;IACJ;EACF;EAEA6B,UAAUA,CAAA,EAAG;IACX/C,OAAO,CAACC,GAAG,CAAC,sDAAsD,EAAE;MAClEf,UAAU,EAAE,IAAI,CAACD,KAAK,CAACC,UAAU;MACjCC,SAAS,EAAE,IAAI,CAACF,KAAK,CAACE,SAAS;MAC/BC,eAAe,EAAE,IAAI,CAACH,KAAK,CAACG,eAAe;MAC3C4D,mBAAmB,EAAE,CAAC,CAAC,IAAI,CAAC1D;IAC9B,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAAC2D,aAAa,EAAE;MACtBjD,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;MAC5D,IAAI,CAACgD,aAAa,CAAChC,OAAO,CAACiC,QAAQ,IAAIC,aAAa,CAACD,QAAQ,CAAC,CAAC;MAC/D,IAAI,CAACD,aAAa,CAACG,KAAK,CAAC,CAAC;MAC1B,IAAI,CAACH,aAAa,GAAG,IAAI,CAAC,CAAC;IAC7B;IAEA,IAAI,CAAChE,KAAK,CAACG,eAAe,GAAG,KAAK;IAClC,IAAI,IAAI,CAACE,gBAAgB,EAAE;MACzBU,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;MAC5DoD,YAAY,CAAC,IAAI,CAAC/D,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC9B;IACA,IAAI,IAAI,CAACR,EAAE,EAAE;MACXkB,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;MAC9D,IAAI,CAACnB,EAAE,CAACwE,KAAK,CAAC,CAAC;MACf,IAAI,CAACxE,EAAE,GAAG,IAAI;IAChB;IACA,IAAI,CAACG,KAAK,CAACC,UAAU,GAAG,KAAK;IAC7B,IAAI,CAACD,KAAK,CAACE,SAAS,GAAG,KAAK;EAC9B;EAEA,MAAMmC,WAAWA,CAACiC,OAAO,EAAE;IACzBvD,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAEsD,OAAO,CAAC;IAC3D,IAAI,CAAC,IAAI,CAACtE,KAAK,CAACE,SAAS,EAAE;MACzBa,OAAO,CAACkB,KAAK,CAAC,wDAAwD,CAAC;MACvE,MAAM,IAAIsC,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IAEA,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,IAAI,CAAC7E,EAAE,CAAC8E,IAAI,CAAC1B,IAAI,CAACU,SAAS,CAACW,OAAO,CAAC,CAAC;QACrCG,OAAO,CAAC,CAAC;MACX,CAAC,CAAC,OAAOxC,KAAK,EAAE;QACdlB,OAAO,CAACkB,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;QACjEyC,MAAM,CAACzC,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEA,MAAM2C,aAAaA,CAAChB,QAAQ,EAAE;IAC5B;IACA,MAAM,IAAI,CAACvB,WAAW,CAAC;MAAED,IAAI,EAAE;IAAa,CAAC,CAAC;EAChD;EAEA,MAAMyC,yBAAyBA,CAACjB,QAAQ,EAAEkB,kBAAkB,EAAE;IAC5D/D,OAAO,CAACC,GAAG,CAAC,oFAAoF,EAAE;MAAE4C,QAAQ;MAAEkB;IAAmB,CAAC,CAAC;IACnI;EACF;EAEA,MAAMC,mBAAmBA,CAACnB,QAAQ,EAAEkB,kBAAkB,EAAEE,KAAK,EAAE;IAC7D,MAAM,IAAI,CAAC3C,WAAW,CAAC;MACrBD,IAAI,EAAE,qBAAqB;MAC3BwB,QAAQ;MACRkB,kBAAkB;MAClBE;IACF,CAAC,CAAC;EACJ;EAEA,MAAMC,kBAAkBA,CAACrB,QAAQ,EAAEkB,kBAAkB,EAAE;IACrD,MAAM,IAAI,CAACzC,WAAW,CAAC;MACrBD,IAAI,EAAE,oBAAoB;MAC1BwB,QAAQ;MACRkB;IACF,CAAC,CAAC;EACJ;EAEAI,UAAUA,CAAA,EAAG;IACXnE,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;IACnC,IAAI,CAACqB,WAAW,CAAC;MACfD,IAAI,EAAE;IACR,CAAC,CAAC;EACJ;EAEA+C,QAAQA,CAACvB,QAAQ,EAAEwB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IAC1BvE,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAE;MAAE4C,QAAQ;MAAEwB,CAAC;MAAEC,CAAC;MAAEC;IAAE,CAAC,CAAC;IACpD,MAAMC,SAAS,GAAGA,CAAA,KAAM;MACtB,IAAI,IAAI,CAAC1F,EAAE,IAAI,IAAI,CAACA,EAAE,CAAC2F,UAAU,KAAKtD,SAAS,CAACuD,IAAI,EAAE;QACpD,IAAIC,UAAU,GAAG;UACftD,IAAI,EAAE,UAAU;UAChBwB,QAAQ,EAAEA,QAAQ;UAClB+B,KAAK,EAAE;YAAEP,CAAC;YAAEC,CAAC;YAAEC;UAAE;QACnB,CAAC;QACD,IAAI,CAACzF,EAAE,CAAC8E,IAAI,CAAC1B,IAAI,CAACU,SAAS,CAAC+B,UAAU,CAAC,CAAC;QACxC,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;;IAED;IACA,IAAIH,SAAS,CAAC,CAAC,EAAE;MACf;IACF;;IAEA;IACA,IAAI,CAAC,IAAI,CAACvF,KAAK,CAACC,UAAU,EAAE;MAC1Bc,OAAO,CAACC,GAAG,CAAC,8DAA8D,CAAC;MAC3E,IAAI,CAACM,OAAO,CAAC,CAAC;;MAEd;MACA,MAAMsE,eAAe,GAAGC,WAAW,CAAC,MAAM;QACxC,IAAI,IAAI,CAAC7F,KAAK,CAACE,SAAS,EAAE;UACxBgE,aAAa,CAAC0B,eAAe,CAAC;UAC9B,IAAIL,SAAS,CAAC,CAAC,EAAE;YACfxE,OAAO,CAACC,GAAG,CAAC,+DAA+D,CAAC;UAC9E,CAAC,MAAM;YACLD,OAAO,CAACkB,KAAK,CAAC,4DAA4D,CAAC;UAC7E;QACF;MACF,CAAC,EAAE,GAAG,CAAC;;MAEP;MACAZ,UAAU,CAAC,MAAM;QACf6C,aAAa,CAAC0B,eAAe,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC5F,KAAK,CAACE,SAAS,EAAE;UACzBa,OAAO,CAACkB,KAAK,CAAC,uDAAuD,CAAC;QACxE;MACF,CAAC,EAAE,IAAI,CAAC;IACV,CAAC,MAAM;MACLlB,OAAO,CAACkB,KAAK,CAAC,kDAAkD,CAAC;IACnE;EACF;EAEA6D,OAAOA,CAAClC,QAAQ,EAAEmC,IAAI,EAAE;IACtBhF,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE;MAAE4C,QAAQ;MAAEmC;IAAK,CAAC,CAAC;IAChD,MAAMC,QAAQ,GAAGA,CAAA,KAAM;MACrB,IAAI,IAAI,CAACnG,EAAE,IAAI,IAAI,CAACA,EAAE,CAAC2F,UAAU,KAAKtD,SAAS,CAACuD,IAAI,EAAE;QACpD,IAAIC,UAAU,GAAG;UACftD,IAAI,EAAE,SAAS;UACfwB,QAAQ,EAAEA,QAAQ;UAClB7B,IAAI,EAAE,CAACgE,IAAI;QACb,CAAC;QACD,IAAI,CAAClG,EAAE,CAAC8E,IAAI,CAAC1B,IAAI,CAACU,SAAS,CAAC+B,UAAU,CAAC,CAAC;QACxC,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;;IAED;IACA,IAAIM,QAAQ,CAAC,CAAC,EAAE;MACd;IACF;;IAEA;IACA,IAAI,CAAC,IAAI,CAAChG,KAAK,CAACC,UAAU,EAAE;MAC1Bc,OAAO,CAACC,GAAG,CAAC,8DAA8D,CAAC;MAC3E,IAAI,CAACM,OAAO,CAAC,CAAC;;MAEd;MACA,MAAMsE,eAAe,GAAGC,WAAW,CAAC,MAAM;QACxC,IAAI,IAAI,CAAC7F,KAAK,CAACE,SAAS,EAAE;UACxBgE,aAAa,CAAC0B,eAAe,CAAC;UAC9B,IAAII,QAAQ,CAAC,CAAC,EAAE;YACdjF,OAAO,CAACC,GAAG,CAAC,8DAA8D,CAAC;UAC7E,CAAC,MAAM;YACLD,OAAO,CAACkB,KAAK,CAAC,2DAA2D,CAAC;UAC5E;QACF;MACF,CAAC,EAAE,GAAG,CAAC;;MAEP;MACAZ,UAAU,CAAC,MAAM;QACf6C,aAAa,CAAC0B,eAAe,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC5F,KAAK,CAACE,SAAS,EAAE;UACzBa,OAAO,CAACkB,KAAK,CAAC,uDAAuD,CAAC;QACxE;MACF,CAAC,EAAE,IAAI,CAAC;IACV,CAAC,MAAM;MACLlB,OAAO,CAACkB,KAAK,CAAC,kDAAkD,CAAC;IACnE;EACF;EAEAgE,aAAaA,CAACrC,QAAQ,EAAEsC,SAAS,EAAE;IACjC;IACA,IAAI,IAAI,CAACrG,EAAE,IAAI,IAAI,CAACA,EAAE,CAAC2F,UAAU,KAAKtD,SAAS,CAACuD,IAAI,EAAE;MACpD;MACA,IAAIC,UAAU,GAAG;QACftD,IAAI,EAAE,eAAe;QACrBwB,QAAQ,EAAEA,QAAQ;QAClB7B,IAAI,EAAE,CAACmE,SAAS;MAClB,CAAC;MACD,IAAI,CAACrG,EAAE,CAAC8E,IAAI,CAAC1B,IAAI,CAACU,SAAS,CAAC+B,UAAU,CAAC,CAAC;IAC1C,CAAC,MAAM;MACL3E,OAAO,CAACkB,KAAK,CAAC,4BAA4B,CAAC;IAC7C;EACF;AACF;;AAEA;AACA,MAAMkE,SAAS,GAAG,IAAIxG,gBAAgB,CAAC,CAAC;AACxC,eAAewG,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}